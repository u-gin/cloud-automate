name: Deploy to EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  # Common env you may use across jobs
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EKS_CLUSTER_NAME: ${{ secrets.EKS_CLUSTER }}
  K8S_NAMESPACE: ${{ secrets.K8S_NAMESPACE }}
  DOCKER_ORG: ${{ secrets.DOCKER_ORG }}
  INGRESS_HOST: ${{ secrets.INGRESS_HOST }}

jobs:
  build-and-push:
    name: Build and push
    runs-on: ubuntu-latest

    strategy:
      matrix:
        app: [postgres, redis, worker, vote, result]

    permissions:
      id-token: write
      contents: read

    steps:
        
      # Checkout Code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Configure AWS Credentials using GitHub OIDC or Secrets
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Login to Docker Hub
      - name: Login to docker hub using username and token\
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Set up buildx for arm architecture
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Assign a short tag based on the commit SHA (immutable) + also push "latest"
      - name: Define image meta
        id: meta
        run: |
          SHA_TAG=${GITHUB_SHA::7}
            echo "sha_tag=$SHA_TAG" >> $GITHUB_OUTPUT

            case "${{ matrix.app }}" in
            postgres)
                echo "image=${{ secrets.DOCKER_USERNAME }}/postgres" >> $GITHUB_OUTPUT
                echo "context=./postgres" >> $GITHUB_OUTPUT
                ;;
            redis)
                echo "image=${{ secrets.DOCKER_USERNAME }}/redis" >> $GITHUB_OUTPUT
                echo "context=./redis" >> $GITHUB_OUTPUT
                ;;
            worker)
                echo "image=${{ secrets.DOCKER_USERNAME }}/worker" >> $GITHUB_OUTPUT
                echo "context=./worker" >> $GITHUB_OUTPUT
                ;;
            vote)
                echo "image=${{ secrets.DOCKER_USERNAME }}/vote" >> $GITHUB_OUTPUT
                echo "context=./vote" >> $GITHUB_OUTPUT
                ;;
            result)
                echo "image=${{ secrets.DOCKER_USERNAME }}/result" >> $GITHUB_OUTPUT
                echo "context=./result" >> $GITHUB_OUTPUT
                ;;
            esac
    
      #Build and push images
      - name: Build and push images to docker hub
        uses: docker/build-push-action@v6
        with:
          context: ${{ steps.meta.outputs.context }}
          file: ${{ steps.meta.outputs.context }}/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.image }}:${{ steps.meta.outputs.sha_tag }}
            ${{ steps.meta.outputs.image }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max


  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: [ build-and-push ]
    permissions:
        contents: read

    steps:
        # Get repo code
      - name: Checkout
        uses: actions/checkout@v4

        # Authenticate to AWS
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
            aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region:            ${{ secrets.AWS_REGION }}

        # Connect kubectl to your EKS cluster
      - name: Update kubeconfig for EKS
        run: |
            aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"

        # Sanity checks
      - name: Verify access
        run: |
            kubectl version --short
            kubectl get ns
            kubectl get ingress -A || true

        # Ensure namespace exists
      - name: Create namespace if missing
        run: |
            kubectl get ns "$K8S_NAMESPACE" || kubectl create ns "$K8S_NAMESPACE"

        # Apply all Kubernetes resources in /k8s
      - name: Apply base k8s
        run: |
            kubectl apply -n "$K8S_NAMESPACE" -f k8s/

        # Compute image tags for all services
      - name: Compute image tags
        id: tag
        run: |
            SHA_TAG=${GITHUB_SHA::7}

            echo "postgres_image=${{ secrets.DOCKER_USERNAME }}/postgres:${SHA_TAG}" >> $GITHUB_OUTPUT
            echo "redis_image=${{ secrets.DOCKER_USERNAME }}/redis:${SHA_TAG}" >> $GITHUB_OUTPUT
            echo "vote_image=${{ secrets.DOCKER_USERNAME }}/vote:${SHA_TAG}" >> $GITHUB_OUTPUT
            echo "result_image=${{ secrets.DOCKER_USERNAME }}/result:${SHA_TAG}" >> $GITHUB_OUTPUT
            echo "worker_image=${{ secrets.DOCKER_USERNAME }}/worker:${SHA_TAG}" >> $GITHUB_OUTPUT

        # Update each deployment with the new image
      - name: Set images to new SHA tag
        run: |
            kubectl -n "$K8S_NAMESPACE" set image deployment/postgres postgres=${{ steps.tag.outputs.postgres_image }}
            kubectl -n "$K8S_NAMESPACE" set image deployment/redis redis=${{ steps.tag.outputs.redis_image }}
            kubectl -n "$K8S_NAMESPACE" set image deployment/vote vote=${{ steps.tag.outputs.vote_image }}
            kubectl -n "$K8S_NAMESPACE" set image deployment/result result=${{ steps.tag.outputs.result_image }}
            kubectl -n "$K8S_NAMESPACE" set image deployment/worker worker=${{ steps.tag.outputs.worker_image }}

        # Patch ingress to ensure correct host
      - name: Patch Ingress host if needed
        shell: bash
        run: |
            CURRENT_HOST=$(kubectl -n "$K8S_NAMESPACE" get ingress -o jsonpath='{.items[0].spec.rules[0].host}')
            if [ "$CURRENT_HOST" != "$INGRESS_HOST" ]; then
            echo "Patching ingress host to $INGRESS_HOST"
            kubectl -n "$K8S_NAMESPACE" patch ingress $(kubectl -n "$K8S_NAMESPACE" get ingress -o jsonpath='{.items[0].metadata.name}') \
                --type='json' \
                -p="[ {\"op\": \"replace\", \"path\": \"/spec/rules/0/host\", \"value\": \"${INGRESS_HOST}\" } ]"
            else
            echo "Ingress already correctly set to $INGRESS_HOST"
            fi

        # Wait for all app rollouts
      - name: Wait for rollout (postgres)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/postgres --timeout=120s

      - name: Wait for rollout (redis)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/redis --timeout=120s

      - name: Wait for rollout (vote)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/vote --timeout=120s

      - name: Wait for rollout (result)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/result --timeout=120s

      - name: Wait for rollout (worker)
        run: kubectl -n "$K8S_NAMESPACE" rollout status deploy/worker --timeout=120s

#      - name: Quick smoke test via Ingress
#        run: |
#          # You need DNS already pointing at the NGINX Ingress ELB (previous lab).
#          # Test the API route:
#          curl -s --fail "http://${INGRESS_HOST}/api/ping" | tee /tmp/api.txt
#          echo
#          echo "Response above should contain a ping or message from backend."
